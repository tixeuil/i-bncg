import random
import networkx as nx
import numpy as np
import copy
import scipy
import pandas as pd
import matplotlib.pyplot as plt
from pathlib import Path
from collections import defaultdict
from multiprocessing import Process

# Computes the social cost of a node in a graph that is interested in specific nodes, using the SUM metric if use_sum is True, and using the MAX metric otherwise
# if the node cannot reach a node it is interested in, the cost is infinite
def social_cost_player(graph,interests,node:int,use_sum=True):
    if not use_sum:
        return social_cost_player_max(graph,interests,node)
    else:
        return social_cost_player_sum(graph,interests,node)

# Computes the social cost of a node in a graph that is interested in specific nodes, using the SUM metric
# if the node cannot reach a node it is interested in, the cost is infinite
def social_cost_player_sum(graph,interests,node:int):
    cost = 0
    spl = dict(nx.all_pairs_shortest_path_length(graph))
    if node in interests:
        for ele in interests[node]:
            if node in spl:
                if ele in spl[node]:
                    cost += spl[node][ele]
                else:
                    cost += float('inf')
    return cost
    
# Computes the social cost of a node in a graph that is interested in specific nodes, using the MAX metric
# if the node cannot reach a node it is interested in, the cost is infinite
def social_cost_player_max(graph,interests,node:int):
    cost = 0
    spl = dict(nx.all_pairs_shortest_path_length(graph))
    if node in interests:
        for ele in interests[node]:
            if node in spl:
                if ele in spl[node]:
                    if cost < spl[node][ele]: 
                        cost = spl[node][ele]
                else:
                    cost = float('inf')
    return cost

# Computes the social cost of graph using the SUM metric if use_sum is True, and using the MAX metric otherwise
# the social cost is equal to the sum of distances between nodes and their interests (communication cost),  
def social_cost_graph(graph,interests,use_sum=True):
    if not use_sum:
        return social_cost_graph_max(graph,interests)
    else:
        return social_cost_graph_sum(graph,interests)
    
# Computes the social cost of graph using the SUM metric
# the social cost is equal to the sum of distances between nodes and their interests (communication cost),  
# plus the number of bought edges (construction cost) 
def social_cost_graph_sum(graph,interests):
    cost = 0
    for node in graph.nodes():
        cost += social_cost_player_sum(graph, interests, node)
    #cost += nx.number_of_edges(graph)
    return cost

# Computes the social cost of graph using the MAX metric
# the social cost is equal to the sum of distances between nodes and their interests (communication cost),  
# plus the number of bought edges (construction cost) 
def social_cost_graph_max(graph,interests):
    cost = 0
    for node in graph.nodes():
        cost += social_cost_player_max(graph, interests, node)
    #cost += nx.number_of_edges(graph)
    return cost

"""
Method to generate a random connected undirected graph
The graph is generated by erdos renyi, selecting p to have a high probability of beign connected
Retry as necessary
"""
def random_connected_undirected_graph(size:int):
    # when p > (1+epsilon) ln(n)/n, the probability that the graph is connected is high
    graph = nx.erdos_renyi_graph(size,1.01*np.log(size)/size,directed=False)
    while not nx.is_connected(graph):
        graph = nx.erdos_renyi_graph(size,1.01*np.log(size)/size,directed=False)
    return graph

"""
Method to compute the best spanning tree of a host graph based on the social cost, based on node interests
Return the best graph (tree) and its associated cost, stating from a host graph given as parameter
"""
def best_spanning_tree(graph,interests,use_sum=True):
    min_cost = float('inf')
    st_min = None

    # search spanning tree with lowest social cost
    for st in nx.SpanningTreeIterator(graph):
        cost = social_cost_graph(st,interests,use_sum)
        if cost < min_cost:
            st_min = st.copy()
            min_cost = cost
    
    return (st_min,min_cost)

"""
Method to compute the best spanning trees of a host graph based on the social cost (for both SUM and MAX metrics), based on node interests
Return the best graph (tree) and its associated cost, stating from a host graph given as parameter
"""
def best_spanning_trees(graph,interests):
    min_cost_sum = float('inf')
    st_min_sum = None
    min_cost_max = float('inf')
    st_min_max = None

    # search spanning tree with lowest social cost
    for st in nx.SpanningTreeIterator(graph):
        cost_sum = social_cost_graph_sum(st,interests)
        if cost_sum < min_cost_sum:
            st_min_sum = st.copy()
            min_cost_sum = cost_sum
        cost_max = social_cost_graph_max(st,interests)
        if cost_max < min_cost_max:
            st_min_max = st.copy()
            min_cost_max = cost_max
    
    return (st_min_sum,min_cost_sum,st_min_max,min_cost_max)
    
"""
Method to compute the best spanning tree based on the social cost
Return the best graph (tree) and its associated cost, stating from a complete host graph of number_nodes
"""
def best_spanning_tree_complete(number_nodes,interests,use_sum=True):
    return best_spanning_tree(nx.complete_graph(number_nodes),interests,use_sum)

"""
Method to compute all spanning tree from a host graph provided as parameter
Returns a list of graphs that are actually spanning trees
"""
def all_spanning_trees(graph):
     res = [st for st in nx.SpanningTreeIterator(graph)]
     return res

"""
Method to update the graph using networkx 
the edge (node,node_to_remove) is deleted
the edge (node,node_to_add) is added
"""
def update_graph(graph,node,node_to_remove,node_to_add):
    graph.remove_edge(node,node_to_remove)
    graph.add_edge(node,node_to_add)
    return graph

"""
Turns a digraph into interests for each node : each node's insterests consists of its outgoing neighbors 
in the input directed graph
"""
def get_interests_from_digraph(graph):
    interests = defaultdict(list)
    for u,v in graph.edges(data=False):
        interests[u].append(v)
    return interests

"""
Turns an undirected graph into interests for each node : each node's insterests consists of its neighbors 
in the input graph
"""
def get_interests_from_graph(graph):
    interests = defaultdict(list)
    for u,v in graph.edges(data=False):
        interests[u].append(v)
        interests[v].append(u)
    return interests

"""
method to compute all swap strategies possible for the node for this turn
--> strategies contains all possibilities for edge swap, the edge to be removed 
is a current neighbor of of the node, while the edge to be added involves any node 
that is not a current neighbor of the current node, but present in the host graph
A solution is a 2-tuple (node_to_remove, node_to_add) in the strategy of the node
Return a list of 2-tuples
"""
def get_swap_strategies_available_host(graph,host_graph,node):

    # get all nodes
    neighbors_available = set([i for i in host_graph.neighbors(node)])

    # remove current node and his neighbors
    if node in neighbors_available:
        neighbors_available.remove(node)
    for ele in graph.neighbors(node):
        if ele in neighbors_available:
            neighbors_available.remove(ele)

    # get all strategies available by swap
    solutions = list()

    for node_to_add in neighbors_available:
        for node_to_remove in graph.neighbors(node):
            tup = (node_to_remove,node_to_add)
            solutions.append(tup)
    
    return solutions

"""
Method to improve the current strategy (wrt social cost for the node)
Returns None if no strategy can improve the current one for the node
"""
def improve_strategy(graph, host_graph, interests, node, allow_disconnect: bool, use_sum=True):
    current_cost = social_cost_player(graph,interests,node,use_sum)
    minimal_cost = current_cost
    minimal_strategy = None
    for node_to_remove, node_to_add in get_swap_strategies_available_host( graph, host_graph, node ): 
        # update graph
        update_graph(graph,node,node_to_remove,node_to_add)

        # check if the graph is disconneted by this solution 
        # --> avoid this solution only we have not the autorisation to deconnect the graph
        if allow_disconnect == False and nx.is_connected(graph) == False:
            update_graph(graph,node,node_to_add,node_to_remove) # get the initial topology
            continue

        tmp_cost = social_cost_player(graph,interests,node,use_sum)# get social cost
        # check if we find a best strategy
        if tmp_cost < minimal_cost : 
            minimal_cost = tmp_cost
            minimal_strategy = (node_to_remove,node_to_add)

        update_graph(graph,node,node_to_add,node_to_remove) # get the initial topology
    return minimal_strategy

"""
Method use to let a player improve its social cost if possible
Return true if cost was improved, False otherwise
"""
def play_node(graph,host_graph,interests,node,allow_disconnect,use_sum=True):
    best_strategy = improve_strategy(graph,host_graph,interests,node,allow_disconnect,use_sum)
    if best_strategy is not None:
        node_to_remove = best_strategy[0]
        node_to_add = best_strategy[1]
        update_graph(graph,node,node_to_remove,node_to_add)
        return True
    else:
         return False

"""
Execute one node at random
"""
def run_one_random_node(graph,host_graph,interests,allow_disconnect:bool,use_sum=True):
    node = random.choice(range(graph.number_of_nodes()))
    play_node(graph,host_graph,interests,node,allow_disconnect,use_sum)

"""
Execute all nodes in a random order
"""
def run_one_random_round(graph,host_graph,interests,allow_disconnect:bool,use_sum=True):
    nodes = np.random.permutation(np.array(range(graph.number_of_nodes())))
    for node in nodes:
        play_node(graph,host_graph,interests,node,allow_disconnect,use_sum)

"""
Method to check if there is a convergence in the game
Returns true if the system has converged (no node can improve its cost)
Returns false otherwise
"""
def has_converged(graph,host_graph,interests,allow_disconnect,use_sum=True):
    for node in graph.nodes() : 
        if improve_strategy(graph,host_graph,interests,node,allow_disconnect,use_sum) is not None:
            return False
    return True
    
"""
Method to compute the best spanning tree, min equilibrium, max equilibrium of a host graph 
based on the social cost, based on node interests
Return the best tree, min eq, max eq and their associated cost 
stating from a host graph given as parameter
"""
def best_spanning_tree_equilibrium(graph,interests,allow_disconnect=False,use_sum=True):
    min_cost = float('inf')
    min_eq_cost = float('inf')
    max_eq_cost = float('0')
    st_min = None
    st_eq_min = None
    st_eq_max = None

    # search spanning tree with lowest social cost
    for st in nx.SpanningTreeIterator(graph):
        cost = social_cost_graph(st,interests,use_sum)
        if cost < min_cost:
            st_min = st.copy()
            min_cost = cost
        if has_converged(st,graph,interests,allow_disconnect,use_sum=True):
            if cost < min_eq_cost:
                st_eq_min = st.copy()
                min_eq_cost = cost
            if cost > max_eq_cost:
                st_eq_max = st.copy()
                max_eq_cost = cost
    return (st_min,min_cost,st_eq_min,min_eq_cost,st_eq_max,max_eq_cost)

"""
Method to compute the best spanning tree, min tree equilibrium, max tree equilibrium of a host graph 
based on the social cost, based on node interests
Return the best tree, min eq, max eq and their associated cost 
stating from a host graph given as parameter
"""
def best_spanning_trees_equilibria(graph,interests):
    min_cost_sum = float('inf')
    min_eq_cost_c_sum = float('inf')
    max_eq_cost_c_sum = float('0')
    min_eq_cost_d_sum = float('inf')
    max_eq_cost_d_sum = float('0')
    st_min_sum = None
    st_eq_min_c_sum = None
    st_eq_max_c_sum = None
    st_eq_min_d_sum = None
    st_eq_max_d_sum = None
    min_cost_max = float('inf')
    min_eq_cost_c_max = float('inf')
    max_eq_cost_c_max = float('0')
    min_eq_cost_d_max = float('inf')
    max_eq_cost_d_max = float('0')
    st_min_max = None
    st_eq_min_c_max = None
    st_eq_max_c_max = None
    st_eq_min_d_max = None
    st_eq_max_d_max = None

    # search spanning tree with lowest social cost
    for st in nx.SpanningTreeIterator(graph):
        cost = social_cost_graph_sum(st,interests)
        if cost < min_cost_sum:
            st_min_sum = st.copy()
            min_cost_sum = cost
        if has_converged(st,graph,interests,False,True):
            if cost < min_eq_cost_c_sum:
                st_eq_min_c_sum = st.copy()
                min_eq_cost_c_sum = cost
            if cost > max_eq_cost_c_sum:
                st_eq_max_c_sum = st.copy()
                max_eq_cost_c_sum = cost
        if has_converged(st,graph,interests,True,True):
            if cost < min_eq_cost_d_sum:
                st_eq_min_d_sum = st.copy()
                min_eq_cost_d_sum = cost
            if cost > max_eq_cost_d_sum:
                st_eq_max_d_sum = st.copy()
                max_eq_cost_d_sum = cost
        
        cost = social_cost_graph_max(st,interests)
        if cost < min_cost_max:
            st_min_max = st.copy()
            min_cost_max = cost
        if has_converged(st,graph,interests,False,False):
            if cost < min_eq_cost_c_max:
                st_eq_min_c_max = st.copy()
                min_eq_cost_c_max = cost
            if cost > max_eq_cost_c_max:
                st_eq_max_c_max = st.copy()
                max_eq_cost_c_max = cost
        if has_converged(st,graph,interests,True,False):
            if cost < min_eq_cost_d_max:
                st_eq_min_d_max = st.copy()
                min_eq_cost_d_max = cost
            if cost > max_eq_cost_d_max:
                st_eq_max_d_max = st.copy()
                max_eq_cost_d_max = cost

    return( st_min_sum,min_cost_sum,
               st_min_max,min_cost_max,
               st_eq_min_c_sum,min_eq_cost_c_sum,
               st_eq_max_c_sum,max_eq_cost_c_sum,
               st_eq_min_d_sum,min_eq_cost_d_sum,
               st_eq_max_d_sum,max_eq_cost_d_sum,
               st_eq_min_c_max,min_eq_cost_c_max,
               st_eq_max_c_max,max_eq_cost_c_max,
               st_eq_min_d_max,min_eq_cost_d_max,
               st_eq_max_d_max,max_eq_cost_d_max,
          )

"""
Method to run a single simulation
takes as input:
- initial topology graph (n nodes)
- host graph (n nodes)
- interests graph (<= n nodes graph)
- limit : maximum number of rounds
- ability to disconnect
Returns:
- a 3-tuple with
    - the final graph (equilibrium graph if the associated number is less than limit)
    - the social cost of the final graph
    - a number
        - a positive (or zero) number if convergence is achieved within limit rounds, this number is the number of rounds to reach convergence
        - a -2 if no convergence is reached and a previous configuration is the same as the current one (hinting at a loop)
        - a -1 if no convergence is reached before limit rounds are run and no previous configuration is the same as the current one (implying no loop)
"""
def run_once(initial_graph, host_graph, interests_graph, limit:int, allow_disconnect:bool, use_sum=True):

    graph = copy.deepcopy(initial_graph)
    hashes = list()
    interests = get_interests_from_graph(interests_graph)

    nb_rounds = 0 
    if has_converged(graph, host_graph, interests, allow_disconnect,use_sum): 
        return (graph,social_cost_graph(graph,interests,use_sum),0)
    else:
        while nb_rounds <= limit:
            hashes.append(nx.weisfeiler_lehman_graph_hash(graph))
            run_one_random_node(graph,host_graph,interests,allow_disconnect,use_sum)
            nb_rounds += 1
            if has_converged(graph,host_graph,interests,allow_disconnect,use_sum):
                return (graph,social_cost_graph(graph,interests,use_sum),nb_rounds)
        if nx.weisfeiler_lehman_graph_hash(graph) in hashes:
            return (graph,social_cost_graph(graph,interests,use_sum),-2)
        else:    
            return (graph,social_cost_graph(graph,interests,use_sum),-1)

"""
This methods runs the simulation how_many times with the same parameters
Returns a list of 3-tuple results
"""
def run_several(initial_graph, host_graph, interests_graph, how_many:int, limit:int, allow_disconnect:bool, use_sum=True):
    res = list()
    for i in range(how_many):
        r = run_once(initial_graph,host_graph,interests_graph,limit,allow_disconnect,use_sum)
        res.append(r)
    return res
        
"""
This method runs one simulation several times and reports:
- the best social cost tree  
- two numpy arrays:
    - costs obtained
    - times obtained
"""
def run_one_simulation(host_graph,interests_graph,nb_initial:int,how_many:int,limit:int,use_sum=True,allow_disconnect=False,save_graphs=False):
    
    #print(f"host graph: {host_graph.edges()}")
    if(save_graphs):
        nx.draw(host_graph,with_labels=True)
        plt.savefig("host_graph.png")
        plt.clf()
    
    #print(f"interests graph: {interests_graph.edges()}")
    if(save_graphs):
        nx.draw(interests_graph,with_labels=True)
        plt.savefig("interests_graph.png")
        plt.clf()
    
    interests = get_interests_from_graph(interests_graph)
    
    st = best_spanning_tree(host_graph,interests,use_sum)
    if(save_graphs):
        nx.draw(st[0],with_labels=True)
        plt.savefig("best_spanning_tree.png")
        plt.clf()
    print(f"Best spanning tree cost: {st[1]}")

    costs = list()
    times = list()
    
    for sample in range(nb_initial):
        initial_graph = nx.random_spanning_tree(host_graph)
    
        res = run_several(initial_graph,host_graph,interests_graph,how_many,limit,allow_disconnect,use_sum)
        
        i = 0
        for r in res:
            if(save_graphs):
                nx.draw(r[0],with_labels=True)
                plt.savefig(f"res_{sample}_{i}_graph.png")
                plt.clf()
            costs.append(r[1])
            times.append(r[2])
            #print(f"Output {sample}-{i} cost:{r[1]} time:{r[2]}")
            i += 1

    return (st[1],costs,times)

"""
This method runs one simulation several times and reports:  
- two numpy arrays:
    - costs obtained
    - times obtained
"""
def run_one_simulation_nb(host_graph,interests_graph,nb_initial:int,how_many:int,limit:int,use_sum=True,allow_disconnect=False,save_graphs=False):
    interests = get_interests_from_graph(interests_graph)
    costs = list()
    times = list()
    
    for sample in range(nb_initial):
        initial_graph = nx.random_spanning_tree(host_graph)
    
        res = run_several(initial_graph,host_graph,interests_graph,how_many,limit,allow_disconnect,use_sum)
        
        i = 0
        for r in res:
            costs.append(r[1])
            times.append(r[2])
            i += 1

    return (costs,times)

"""
This method runs one simulation campaign, with a given host graph, varying the probability of existence of each interest
It returns five dataframes:
- the cost of the optimal social cost tree
- the minimum cost of the equilibrium social cost
- the maximum cost of the equilibrium social cost
- the cost of the equilibrium social cost
- the time to reach the equilibrium social cost
"""    
def run_campaign(host_graph,allow_disconnect_p=False,use_sum_p=True):
    how_many_per_interest_graph_and_initial_tree = 10 
    nb_initial_tree = 10
    nb_interest_graph = 10
    limit = 1000

    df_optimal = pd.DataFrame()
    df_min_cost = pd.DataFrame()
    df_max_cost = pd.DataFrame()
    df_cost = pd.DataFrame()
    df_time = pd.DataFrame()

    for p in [0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.0]:
        optimals = list()
        min_costs = list()
        max_costs = list()
        costs = list()
        times = list()
        for i in range(nb_interest_graph):
            interests_graph = nx.erdos_renyi_graph(host_graph.number_of_nodes(),p,directed=True)
            res = run_one_simulation(host_graph,interests_graph,nb_initial_tree,how_many_per_interest_graph_and_initial_tree,limit,allow_disconnect=allow_disconnect_p,use_sum=use_sum_p)
            optimals.append(res[0])
            min_costs.append(min(res[1]))
            max_costs.append(max(res[1]))
            costs.extend(res[1])
            times.extend(res[2])
        df_optimal[p] = optimals
        df_min_cost[p] = min_costs
        df_max_cost[p] = max_costs
        df_cost[p] = costs
        df_time[p] = times
    return (df_optimal,df_cost,df_time,df_min_cost,df_max_cost)

"""
This method runs one simulation campaign, with the pertersen graph as a host graph, varying the probability of existence of each interest
It returns five dataframes:
- the cost of the optimal social cost tree
- the minimum cost of the equilibrium social cost
- the maximum cost of the equilibrium social cost
- the cost of the equilibrium social cost
- the time to reach the equilibrium social cost
"""    
def run_campaign_petersen(allow_disconnect=False,use_sum=True):
    return run_campaign(nx.petersen_graph(),allow_disconnect,use_sum)

"""
This method runs one simulation campaign, with a complete graph of size nodes as a host graph, varying the probability of existence of each interest
It returns five dataframes:
- the cost of the optimal social cost tree
- the minimum cost of the equilibrium social cost
- the maximum cost of the equilibrium social cost
- the cost of the equilibrium social cost
- the time to reach the equilibrium social cost
"""
def run_campaign_complete(size:int,allow_disconnect=False,use_sum=True):
    return run_campaign(nx.complete_graph(size),allow_disconnect,use_sum)

"""
This method runs one simulation campaign, with a random graph of size nodes as a host graph, 
where each (undirected) edge has probability p, varying the probability of existence of each interest
It returns five dataframes:
- the cost of the optimal social cost tree
- the minimum cost of the equilibrium social cost
- the maximum cost of the equilibrium social cost
- the cost of the equilibrium social cost
- the time to reach the equilibrium social cost
"""
def run_campaign_random(size:int,p:float,allow_disconnect=False,use_sum=True):
    return run_campaign(nx.erdos_renyi_graph(size,p),allow_disconnect,use_sum)

"""
This method runs howmany simulations campaign, with a random graph of size nodes as a host graph (different in each campaign), 
where each (undirected) edge has probability p, varying the probability of existence of each interest
It returns five dataframes:
- the cost of the optimal social cost tree
- the minimum cost of the equilibrium social cost
- the maximum cost of the equilibrium social cost
- the cost of the equilibrium social cost
- the time to reach the equilibrium social cost
"""
def run_campaign_random_multi(size:int,p:float,how_many:int,allow_disconnect=False,use_sum=True):
    l_df_optimal = list()
    l_df_cost = list()
    l_df_time = list()
    l_df_min_cost = list()
    l_df_max_cost = list()
    for i in range(how_many):
        df_optimal,df_cost,df_time,df_min_cost,df_max_cost = run_campaign(nx.erdos_renyi_graph(size,p),allow_disconnect,use_sum)
        l_df_optimal.append(df_optimal)
        l_df_cost.append(df_cost)
        l_df_time.append(df_time)
        l_df_min_cost.append(df_min_cost)
        l_df_max_cost.append(df_max_cost)
    return(pd.concat(l_df_optimal, ignore_index = True),pd.concat(l_df_cost, ignore_index = True),pd.concat(l_df_time, ignore_index = True),pd.concat(l_df_min_cost, ignore_index = True),pd.concat(l_df_max_cost, ignore_index = True))    

"""
This method runs howmany simulations campaign, with a random connected graph of size nodes as a host graph (different in each campaign), 
varying the probability of existence of each interest
It returns five dataframes:
- the cost of the optimal social cost tree
- the minimum cost of the equilibrium social cost
- the maximum cost of the equilibrium social cost
- the cost of the equilibrium social cost
- the time to reach the equilibrium social cost
"""
def run_campaign_random_multi_connected(size:int,how_many:int,allow_disconnect=False,use_sum=True):
    l_df_optimal = list()
    l_df_cost = list()
    l_df_time = list()
    l_df_min_cost = list()
    l_df_max_cost = list()
    for i in range(how_many):
        df_optimal,df_cost,df_time,df_min_cost,df_max_cost = run_campaign(random_connected_graph(size),allow_disconnect,use_sum)
        l_df_optimal.append(df_optimal)
        l_df_cost.append(df_cost)
        l_df_time.append(df_time)
        l_df_min_cost.append(df_min_cost)
        l_df_max_cost.append(df_max_cost)
    return(pd.concat(l_df_optimal, ignore_index = True),pd.concat(l_df_cost, ignore_index = True),pd.concat(l_df_time, ignore_index = True),pd.concat(l_df_min_cost, ignore_index = True),pd.concat(l_df_max_cost, ignore_index = True))    

"""
This method runs one simulation campaign, with a ring graph of size nodes as a host graph, varying the probability of existence of each interest
It returns five dataframes:
- the cost of the optimal social cost tree
- the minimum cost of the equilibrium social cost
- the maximum cost of the equilibrium social cost
- the cost of the equilibrium social cost
- the time to reach the equilibrium social cost
"""
def run_campaign_ring(size:int,allow_disconnect=False,use_sum=True):
    return run_campaign(nx.cycle_graph(size),allow_disconnect,use_sum)

def lcc_diameter(g):
    lcc = max(nx.connected_components(g.to_undirected()), key=len)
    lcc_g = g.subgraph(lcc).copy().to_undirected()
    return nx.diameter(lcc_g)

"""
This method runs one simulation several times and reports:
- the diameter of the host graph
- the diameter of the interests graph
- three numpy arrays:
    - diameters of equilibrium graphs obtained
    - costs of equilibrium graphs obtained
    - times to reach equilibrium obtained
"""
def run_one_simulation_best_diam(host_graph,interests_graph,nb_initial:int,how_many:int,limit:int,use_sum=True,allow_disconnect=False,save_graphs=False):
    interests = get_interests_from_graph(interests_graph)
    costs = list()
    times = list()
    host_diameter = lcc_diameter(host_graph)
    interest_diameter = lcc_diameter(interests_graph)
    equilibrium_diameters = list()

    for sample in range(nb_initial):
        initial_graph = nx.random_spanning_tree(host_graph)
    
        res = run_several(initial_graph,host_graph,interests_graph,how_many,limit,allow_disconnect,use_sum)
        
        i = 0
        for r in res:
            equilibrium_diameters.append(lcc_diameter(r[0]))
            costs.append(r[1])
            times.append(r[2])
            i += 1

    return ([host_diameter],[interest_diameter],equilibrium_diameters,costs,times)
    
"""
This method runs one simulation campaign, with a given host graph, varying the probability of existence of each interest
It returns five dataframes:
- the diameters of the host graph (should be all equals)
- the diameters of the interests graphs
- the diameters of the equilibrium graphs
- the costs of the equilibrium social cost
- the times to reach the equilibrium social cost

"""    
def run_campaign_best_diam(host_graph):
    how_many_per_interest_graph_and_initial_tree = 10 
    nb_initial_tree = 10
    nb_interest_graph = 10
    limit = 1000

    host_diameter = nx.diameter(host_graph)

    df_st_min_s = pd.DataFrame()
    df_st_min_m = pd.DataFrame()
    df_st_min_cost_eq_c_s = pd.DataFrame()
    df_st_max_cost_eq_c_s = pd.DataFrame()
    df_st_min_cost_eq_c_m = pd.DataFrame()
    df_st_max_cost_eq_c_m = pd.DataFrame()
    df_st_min_cost_eq_d_s = pd.DataFrame()
    df_st_max_cost_eq_d_s = pd.DataFrame()
    df_st_min_cost_eq_d_m = pd.DataFrame()
    df_st_max_cost_eq_d_m = pd.DataFrame()
    
    df_cost_c_s = pd.DataFrame()
    df_time_c_s = pd.DataFrame()
    df_host_diameters_c_s = pd.DataFrame()
    df_interests_diameters_c_s = pd.DataFrame()
    df_equilibrium_diameters_c_s = pd.DataFrame()
    df_cost_c_m = pd.DataFrame()
    df_time_c_m = pd.DataFrame()
    df_host_diameters_c_m = pd.DataFrame()
    df_interests_diameters_c_m = pd.DataFrame()
    df_equilibrium_diameters_c_m = pd.DataFrame()
    df_cost_d_s = pd.DataFrame()
    df_time_d_s = pd.DataFrame()
    df_host_diameters_d_s = pd.DataFrame()
    df_interests_diameters_d_s = pd.DataFrame()
    df_equilibrium_diameters_d_s = pd.DataFrame()
    df_cost_d_m = pd.DataFrame()
    df_time_d_m = pd.DataFrame()
    df_host_diameters_d_m = pd.DataFrame()
    df_interests_diameters_d_m = pd.DataFrame()
    df_equilibrium_diameters_d_m = pd.DataFrame()
    
    for p in [0.0,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.0]:
        costs_c_s = list()
        times_c_s = list()
        h_diameters_c_s = list()
        i_diameters_c_s = list()
        e_diameters_c_s = list()
        costs_c_m = list()
        times_c_m = list()
        h_diameters_c_m = list()
        i_diameters_c_m = list()
        e_diameters_c_m = list()
        costs_d_s = list()
        times_d_s = list()
        h_diameters_d_s = list()
        i_diameters_d_s = list()
        e_diameters_d_s = list()
        costs_d_m = list()
        times_d_m = list()
        h_diameters_d_m = list()
        i_diameters_d_m = list()
        e_diameters_d_m = list()

        st_min_s = list()
        st_min_m = list()
        st_min_cost_eq_c_s = list()
        st_max_cost_eq_c_s = list()
        st_min_cost_eq_c_m = list()
        st_max_cost_eq_c_m = list()
        st_min_cost_eq_d_s = list()
        st_max_cost_eq_d_s = list()
        st_min_cost_eq_d_m = list()
        st_max_cost_eq_d_m = list()
        
        for i in range(nb_interest_graph):
            interests_graph = nx.erdos_renyi_graph(host_graph.number_of_nodes(),p,directed=False)
            #print("considering new interest graph")

            st_min_sum, min_cost_sum, st_min_max, min_cost_max, st_eq_min_c_sum, min_eq_cost_c_sum, st_eq_max_c_sum, max_eq_cost_c_sum, st_eq_min_d_sum, min_eq_cost_d_sum, st_eq_max_d_sum, max_eq_cost_d_sum, st_eq_min_c_max, min_eq_cost_c_max, st_eq_max_c_max, max_eq_cost_c_max, st_eq_min_d_max, min_eq_cost_d_max, st_eq_max_d_max,max_eq_cost_d_max = best_spanning_trees_equilibria(host_graph, interests_graph)
            st_min_s.extend([min_cost_sum])
            st_min_m.extend([min_cost_max])
            st_min_cost_eq_c_s.extend([min_eq_cost_c_sum])
            st_max_cost_eq_c_s.extend([max_eq_cost_c_sum])
            st_min_cost_eq_c_m.extend([min_eq_cost_c_max])
            st_max_cost_eq_c_m.extend([max_eq_cost_c_max])
            st_min_cost_eq_d_s.extend([min_eq_cost_d_sum])
            st_max_cost_eq_d_s.extend([max_eq_cost_d_sum])
            st_min_cost_eq_d_m.extend([min_eq_cost_d_max])
            st_max_cost_eq_d_m.extend([max_eq_cost_d_max])
            #print("optimal trees computed")
        
            res = run_one_simulation_best_diam(host_graph,interests_graph,nb_initial_tree,how_many_per_interest_graph_and_initial_tree,limit,allow_disconnect=False,use_sum=True)
            h_diameters_c_s.extend(res[0])
            i_diameters_c_s.extend(res[1])
            e_diameters_c_s.extend(res[2])
            costs_c_s.extend(res[3])
            times_c_s.extend(res[4])
            #print("connected sum equilibrium computed")
        
            res = run_one_simulation_best_diam(host_graph,interests_graph,nb_initial_tree,how_many_per_interest_graph_and_initial_tree,limit,allow_disconnect=False,use_sum=False)
            h_diameters_c_m.extend(res[0])
            i_diameters_c_m.extend(res[1])
            e_diameters_c_m.extend(res[2])
            costs_c_m.extend(res[3])
            times_c_m.extend(res[4])
            #print("connected max equilibrium computed")
            
            res = run_one_simulation_best_diam(host_graph,interests_graph,nb_initial_tree,how_many_per_interest_graph_and_initial_tree,limit,allow_disconnect=True,use_sum=True)
            h_diameters_d_s.extend(res[0])
            i_diameters_d_s.extend(res[1])
            e_diameters_d_s.extend(res[2])
            costs_d_s.extend(res[3])
            times_d_s.extend(res[4])
            #print("disconnected sum equilibrium computed")
    
            res = run_one_simulation_best_diam(host_graph,interests_graph,nb_initial_tree,how_many_per_interest_graph_and_initial_tree,limit,allow_disconnect=True,use_sum=False)
            h_diameters_d_m.extend(res[0])
            i_diameters_d_m.extend(res[1])
            e_diameters_d_m.extend(res[2])
            costs_d_m.extend(res[3])
            times_d_m.extend(res[4])
            #print("disconnected max equilibrium computed")

        df_st_min_s[p] = st_min_s 
        df_st_min_m[p] = st_min_m 
        df_st_min_cost_eq_c_s[p] = st_min_cost_eq_c_s 
        df_st_max_cost_eq_c_s[p] = st_max_cost_eq_c_s 
        df_st_min_cost_eq_c_m[p] = st_min_cost_eq_c_m 
        df_st_max_cost_eq_c_m[p] = st_max_cost_eq_c_m 
        df_st_min_cost_eq_d_s[p] = st_min_cost_eq_d_s 
        df_st_max_cost_eq_d_s[p] = st_max_cost_eq_d_s 
        df_st_min_cost_eq_d_m[p] = st_min_cost_eq_d_m 
        df_st_max_cost_eq_d_m[p] = st_max_cost_eq_d_m 
    
        df_host_diameters_c_s[p] = h_diameters_c_s
        df_interests_diameters_c_s[p] = i_diameters_c_s
        df_equilibrium_diameters_c_s[p] = e_diameters_c_s
        df_cost_c_s[p] = costs_c_s
        df_time_c_s[p] = times_c_s
        
        df_host_diameters_c_m[p] = h_diameters_c_m
        df_interests_diameters_c_m[p] = i_diameters_c_m
        df_equilibrium_diameters_c_m[p] = e_diameters_c_m
        df_cost_c_m[p] = costs_c_m
        df_time_c_m[p] = times_c_m
        
        df_host_diameters_d_s[p] = h_diameters_d_s
        df_interests_diameters_d_s[p] = i_diameters_d_s
        df_equilibrium_diameters_d_s[p] = e_diameters_d_s
        df_cost_d_s[p] = costs_d_s
        df_time_d_s[p] = times_d_s
        
        df_host_diameters_d_m[p] = h_diameters_d_m
        df_interests_diameters_d_m[p] = i_diameters_d_m
        df_equilibrium_diameters_d_m[p] = e_diameters_d_m
        df_cost_d_m[p] = costs_d_m
        df_time_d_m[p] = times_d_m
        
    return ( df_st_min_s, df_st_min_m, df_st_min_cost_eq_c_s, df_st_max_cost_eq_c_s, df_st_min_cost_eq_c_m, df_st_max_cost_eq_c_m, df_st_min_cost_eq_d_s, df_st_max_cost_eq_d_s, df_st_min_cost_eq_d_m, df_st_max_cost_eq_d_m, 
        df_host_diameters_c_s, df_interests_diameters_c_s, df_equilibrium_diameters_c_s, df_cost_c_s, df_time_c_s,
        df_host_diameters_c_m, df_interests_diameters_c_m, df_equilibrium_diameters_c_m, df_cost_c_m, df_time_c_m,
        df_host_diameters_d_s, df_interests_diameters_d_s, df_equilibrium_diameters_d_s, df_cost_d_s, df_time_d_s,
        df_host_diameters_d_m, df_interests_diameters_d_m, df_equilibrium_diameters_d_m, df_cost_d_m, df_time_d_m
    )

"""
This method runs one simulation campaign, with the pertersen graph as a host graph, varying the probability of existence of each interest
It returns five dataframes:
- the diameters of the host graph (should be all equals)
- the diameters of the interests graphs
- the diameters of the equilibrium graphs
- the costs of the equilibrium social cost
- the times to reach the equilibrium social cost
"""    
def run_campaign_petersen_best_diam():
    return run_campaign_best_diam(nx.petersen_graph())

"""
This method runs one simulation campaign, with a complete graph of size nodes as a host graph, varying the probability of existence of each interest
It returns five dataframes:
- the diameters of the host graph (should be all equals)
- the diameters of the interests graphs
- the diameters of the equilibrium graphs
- the costs of the equilibrium social cost
- the times to reach the equilibrium social cost
"""
def run_campaign_complete_best_diam(size:int):
    return run_campaign_best_diam(nx.complete_graph(size))

"""
This method runs one simulation campaign, with a random graph of size nodes as a host graph, 
where each (undirected) edge has probability p, varying the probability of existence of each interest
It returns five dataframes:
- the diameters of the host graph (should be all equals)
- the diameters of the interests graphs
- the diameters of the equilibrium graphs
- the costs of the equilibrium social cost
- the times to reach the equilibrium social cost
"""
def run_campaign_random_best_diam(size:int,p:float):
    return run_campaign_best_diam(nx.erdos_renyi_graph(size,p))

"""
This method runs one simulation campaign, with a random graph of size nodes as a host graph, 
where each (undirected) edge has probability p, varying the probability of existence of each interest
It returns five dataframes:
- the diameters of the host graph (should be all equals)
- the diameters of the interests graphs
- the diameters of the equilibrium graphs
- the costs of the equilibrium social cost
- the times to reach the equilibrium social cost
"""
def run_campaign_random_connected_best_diam(size:int):
    return run_campaign_best_diam(random_connected_graph(size))

"""
This method runs howmany simulations campaign, with a random connected graph of size nodes as a host graph (different in each campaign), 
varying the probability of existence of each interest
It returns five dataframes:
- the cost of the optimal social cost tree
- the minimum cost of the equilibrium social cost
- the maximum cost of the equilibrium social cost
- the cost of the equilibrium social cost
- the time to reach the equilibrium social cost
"""
def run_campaign_random_multi_connected_best_diam(size:int,how_many:int):
    l_df_st_min_s = pd.DataFrame()
    l_df_st_min_m = pd.DataFrame()
    l_df_st_min_cost_eq_c_s = pd.DataFrame()
    l_df_st_max_cost_eq_c_s = pd.DataFrame()
    l_df_st_min_cost_eq_c_m = pd.DataFrame()
    l_df_st_max_cost_eq_c_m = pd.DataFrame()
    l_df_st_min_cost_eq_d_s = pd.DataFrame()
    l_df_st_max_cost_eq_d_s = pd.DataFrame()
    l_df_st_min_cost_eq_d_m = pd.DataFrame()
    l_df_st_max_cost_eq_d_m = pd.DataFrame()
    
    l_df_cost_c_s = pd.DataFrame()
    l_df_time_c_s = pd.DataFrame()
    l_df_host_diameters_c_s = pd.DataFrame()
    l_df_interests_diameters_c_s = pd.DataFrame()
    l_df_equilibrium_diameters_c_s = pd.DataFrame()
    l_df_cost_c_m = pd.DataFrame()
    l_df_time_c_m = pd.DataFrame()
    l_df_host_diameters_c_m = pd.DataFrame()
    l_df_interests_diameters_c_m = pd.DataFrame()
    l_df_equilibrium_diameters_c_m = pd.DataFrame()
    l_df_cost_d_s = pd.DataFrame()
    l_df_time_d_s = pd.DataFrame()
    l_df_host_diameters_d_s = pd.DataFrame()
    l_df_interests_diameters_d_s = pd.DataFrame()
    l_df_equilibrium_diameters_d_s = pd.DataFrame()
    l_df_cost_d_m = pd.DataFrame()
    l_df_time_d_m = pd.DataFrame()
    l_df_host_diameters_d_m = pd.DataFrame()
    l_df_interests_diameters_d_m = pd.DataFrame()
    l_df_equilibrium_diameters_d_m = pd.DataFrame()
    
    for i in range(how_many):
        df_st_min_s, df_st_min_m, df_st_min_cost_eq_c_s, df_st_max_cost_eq_c_s, df_st_min_cost_eq_c_m, df_st_max_cost_eq_c_m, df_st_min_cost_eq_d_s, df_st_max_cost_eq_d_s, df_st_min_cost_eq_d_m, df_st_max_cost_eq_d_m, df_host_diameters_c_s, df_interests_diameters_c_s, df_equilibrium_diameters_c_s, df_cost_c_s, df_time_c_s, df_host_diameters_c_m, df_interests_diameters_c_m, df_equilibrium_diameters_c_m, df_cost_c_m, df_time_c_m, df_host_diameters_d_s, df_interests_diameters_d_s, df_equilibrium_diameters_d_s, df_cost_d_s, df_time_d_s, df_host_diameters_d_m, df_interests_diameters_d_m, df_equilibrium_diameters_d_m, df_cost_d_m, df_time_d_m = run_campaign_best_diam(random_connected_undirected_graph(size))

        l_df_st_min_s = pd.concat([l_df_st_min_s,df_st_min_s])
        l_df_st_min_m = pd.concat([l_df_st_min_m,df_st_min_m])
        l_df_st_min_cost_eq_c_s = pd.concat([l_df_st_min_cost_eq_c_s,df_st_min_cost_eq_c_s])
        l_df_st_max_cost_eq_c_s = pd.concat([l_df_st_max_cost_eq_c_s,df_st_max_cost_eq_c_s])
        l_df_st_min_cost_eq_c_m = pd.concat([l_df_st_min_cost_eq_c_m,df_st_min_cost_eq_c_m])
        l_df_st_max_cost_eq_c_m = pd.concat([l_df_st_max_cost_eq_c_m,df_st_max_cost_eq_c_m])
        l_df_st_min_cost_eq_d_s = pd.concat([l_df_st_min_cost_eq_d_s,df_st_min_cost_eq_d_s])
        l_df_st_max_cost_eq_d_s = pd.concat([l_df_st_max_cost_eq_d_s,df_st_max_cost_eq_d_s])
        l_df_st_min_cost_eq_d_m = pd.concat([l_df_st_min_cost_eq_d_m,df_st_min_cost_eq_d_m])
        l_df_st_max_cost_eq_d_m = pd.concat([l_df_st_max_cost_eq_d_m,df_st_min_cost_eq_d_m])
        l_df_host_diameters_c_s = pd.concat([l_df_host_diameters_c_s,df_host_diameters_c_s])
        l_df_interests_diameters_c_s = pd.concat([l_df_interests_diameters_c_s,df_interests_diameters_c_s])
        l_df_equilibrium_diameters_c_s = pd.concat([l_df_equilibrium_diameters_c_s,df_equilibrium_diameters_c_s])
        l_df_cost_c_s = pd.concat([l_df_cost_c_s,df_cost_c_s])
        l_df_time_c_s = pd.concat([l_df_time_c_s,df_time_c_s])
        l_df_host_diameters_c_m = pd.concat([l_df_host_diameters_c_m,df_host_diameters_c_m])
        l_df_interests_diameters_c_m = pd.concat([l_df_interests_diameters_c_m,df_interests_diameters_c_m])
        l_df_equilibrium_diameters_c_m = pd.concat([l_df_equilibrium_diameters_c_m,df_equilibrium_diameters_c_m])
        l_df_cost_c_m = pd.concat([l_df_cost_c_m,df_cost_c_m])
        l_df_time_c_m = pd.concat([l_df_time_c_m,df_time_c_m])
        l_df_host_diameters_d_s = pd.concat([l_df_host_diameters_d_s,df_host_diameters_d_s])
        l_df_interests_diameters_d_s = pd.concat([l_df_interests_diameters_d_s,df_interests_diameters_d_s])
        l_df_equilibrium_diameters_d_s = pd.concat([l_df_equilibrium_diameters_d_s,df_equilibrium_diameters_d_s])
        l_df_cost_d_s = pd.concat([l_df_cost_d_s,df_cost_d_s])
        l_df_time_d_s = pd.concat([l_df_time_d_s,df_time_d_s])
        l_df_host_diameters_d_m = pd.concat([l_df_host_diameters_d_m,df_host_diameters_d_m])
        l_df_interests_diameters_d_m = pd.concat([l_df_interests_diameters_d_m,df_interests_diameters_d_m])
        l_df_equilibrium_diameters_d_m = pd.concat([l_df_equilibrium_diameters_d_m,df_equilibrium_diameters_d_m])
        l_df_cost_d_m = pd.concat([l_df_cost_d_m,df_cost_d_m])
        l_df_time_d_m = pd.concat([l_df_time_d_m,df_time_d_m])
        
    return(l_df_st_min_s, l_df_st_min_m, l_df_st_min_cost_eq_c_s, l_df_st_max_cost_eq_c_s, l_df_st_min_cost_eq_c_m, l_df_st_max_cost_eq_c_m, l_df_st_min_cost_eq_d_s, l_df_st_max_cost_eq_d_s, l_df_st_min_cost_eq_d_m, l_df_st_max_cost_eq_d_m, 
        l_df_host_diameters_c_s, l_df_interests_diameters_c_s, l_df_equilibrium_diameters_c_s, l_df_cost_c_s, l_df_time_c_s,
        l_df_host_diameters_c_m, l_df_interests_diameters_c_m, l_df_equilibrium_diameters_c_m, l_df_cost_c_m, l_df_time_c_m,
        l_df_host_diameters_d_s, l_df_interests_diameters_d_s, l_df_equilibrium_diameters_d_s, l_df_cost_d_s, l_df_time_d_s,
        l_df_host_diameters_d_m, l_df_interests_diameters_d_m, l_df_equilibrium_diameters_d_m, l_df_cost_d_m, l_df_time_d_m)    

"""
This method runs one simulation campaign, with a ring graph of size nodes as a host graph, varying the probability of existence of each interest
It returns five dataframes:
- the diameters of the host graph (should be all equals)
- the diameters of the interests graphs
- the diameters of the equilibrium graphs
- the costs of the equilibrium social cost
- the times to reach the equilibrium social cost
"""
def run_campaign_ring_best_diam(size:int):
    return run_campaign_best_diam(nx.cycle_graph(size))

def run_campaign_from_string(s):
    match s:
        case "petersen": 
            return run_campaign_petersen_best_diam()
        case "ring_4":
            return run_campaign_ring_best_diam(4)
        case "ring_5":
            return run_campaign_ring_best_diam(5)
        case "ring_10":
            return run_campaign_ring_best_diam(10)
        case "ring_15":
            return run_campaign_ring_best_diam(15)
        case "ring_20":
            return run_campaign_ring_best_diam(20)
        case "random_4":
            return run_campaign_random_multi_connected_best_diam(4,10)
        case "random_5":
            return run_campaign_random_multi_connected_best_diam(5,10)
        case "random_8":
            return run_campaign_random_multi_connected_best_diam(8,10)
        case "random_10":
            return run_campaign_random_multi_connected_best_diam(10,10)
        case "complete_3":
            return run_campaign_complete_best_diam(3)
        case "complete_4":
            return run_campaign_complete_best_diam(4)
        case "complete_5":
            return run_campaign_complete_best_diam(5)
        case "complete_8":
            return run_campaign_complete_best_diam(8)
        case "complete_10":
            return run_campaign_complete_best_diam(10)

def run_and_save_campaign_from_string(s,r):
    print(f"Start {r}/{s}")
    # Get data
    df_st_min_s, df_st_min_m, df_st_min_cost_eq_c_s, df_st_max_cost_eq_c_s, df_st_min_cost_eq_c_m, df_st_max_cost_eq_c_m, df_st_min_cost_eq_d_s, df_st_max_cost_eq_d_s, df_st_min_cost_eq_d_m, df_st_max_cost_eq_d_m, df_host_diameters_c_s, df_interests_diameters_c_s, df_equilibrium_diameters_c_s, df_cost_c_s, df_time_c_s, df_host_diameters_c_m, df_interests_diameters_c_m, df_equilibrium_diameters_c_m, df_cost_c_m, df_time_c_m, df_host_diameters_d_s, df_interests_diameters_d_s, df_equilibrium_diameters_d_s, df_cost_d_s, df_time_d_s, df_host_diameters_d_m, df_interests_diameters_d_m, df_equilibrium_diameters_d_m, df_cost_d_m, df_time_d_m = run_campaign_from_string(s)

    # Save data in files
    p = Path(r) / s
    p.mkdir(parents=True, exist_ok=True)
    
    df_st_min_s.to_csv(p/"df_st_min_s.csv")
    df_st_min_m.to_csv(p/"df_st_min_m.csv")
    df_st_min_cost_eq_c_s.to_csv(p/"df_st_min_cost_eq_c_s.csv")
    df_st_max_cost_eq_c_s.to_csv(p/"df_st_max_cost_eq_c_s.csv")
    df_st_min_cost_eq_c_m.to_csv(p/"df_st_min_cost_eq_c_m.csv")
    df_st_max_cost_eq_c_m.to_csv(p/"df_st_max_cost_eq_c_m.csv")
    df_st_min_cost_eq_d_s.to_csv(p/"df_st_min_cost_eq_d_s.csv")
    df_st_max_cost_eq_d_s.to_csv(p/"df_st_max_cost_eq_d_s.csv")
    df_st_min_cost_eq_d_m.to_csv(p/"df_st_min_cost_eq_d_m.csv")
    df_st_max_cost_eq_d_m.to_csv(p/"df_st_max_cost_eq_d_m.csv")
    df_host_diameters_c_s.to_csv(p/"df_host_diameters_c_s.csv")
    df_interests_diameters_c_s.to_csv(p/"df_interests_diameters_c_s.csv")
    df_equilibrium_diameters_c_s.to_csv(p/"df_equilibrium_diameters_c_s.csv")
    df_cost_c_s.to_csv(p/"df_cost_c_s.csv")
    df_time_c_s.to_csv(p/"df_time_c_s.csv")
    df_host_diameters_c_m.to_csv(p/"df_host_diameters_c_m.csv")
    df_interests_diameters_c_m.to_csv(p/"df_interests_diameters_c_m.csv")
    df_equilibrium_diameters_c_m.to_csv(p/"df_equilibrium_diameters_c_m.csv")
    df_cost_c_m.to_csv(p/"df_cost_c_m.csv")
    df_time_c_m.to_csv(p/"df_time_c_m.csv") 
    df_host_diameters_d_s.to_csv(p/"df_host_diameters_d_s.csv")
    df_interests_diameters_d_s.to_csv(p/"df_interests_diameters_d_s.csv")
    df_equilibrium_diameters_d_s.to_csv(p/"df_equilibrium_diameters_d_s.csv")
    df_cost_d_s.to_csv(p/"df_costs_d_s.csv")
    df_time_d_s.to_csv(p/"df_time_d_s.csv")
    df_host_diameters_d_m.to_csv(p/"df_host_diameters_d_m.csv")
    df_interests_diameters_d_m.to_csv(p/"df_interests_diameters_d_m.csv")
    df_equilibrium_diameters_d_m.to_csv(p/"df_equilibrium_diameters_d_m.csv")
    df_cost_d_m.to_csv(p/"df_cost_d_m.csv")
    df_time_d_m.to_csv(p/"df_time_d_m.csv")
    
    print(f"Complete {r}/{s}")

# Run simulations on 32 processors at the same time and store the results in different directories indicated in 'dirs'
# adjust 'dirs' to your number of processors/cores
simulations = ["ring_10","petersen","random_10","complete_8"]
dirs = ["r01","r02","r03","r04","r05","r06","r07","r08","r09","r10","r11","r12","r13","r14","r15","r16","r17","r18","r19","r20","r21","r22","r23","r24","r25","r26","r27","r28","r29","r30","r31","r32"]

def run_process(r):
    global simulations
    for s in simulations:
        run_and_save_campaign_from_string(s,r)

for r in dirs:
    Process(target=run_process,args=(r,)).start()

